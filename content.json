{"meta":{"title":"Zengyu's Cottage","subtitle":null,"description":null,"author":"Zengyu Zeng","url":"https://zengzengyu.com"},"pages":[{"title":"Java处理数据库表获取字段名","date":"2017-07-10T12:03:04.000Z","updated":"2021-10-28T08:03:23.554Z","comments":true,"path":"archive/Java处理数据库表获取字段名.html","permalink":"https://zengzengyu.com/archive/Java%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%E5%90%8D.html","excerpt":"利用 Java 处理所提供的数据库表描述，来获取当中的字段名并输出，便于 ARES 应用。","text":"利用 Java 处理所提供的数据库表描述，来获取当中的字段名并输出，便于 ARES 应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.*;public class Main &#123; public static void doSegmentName()&#123; String fileLoc = &quot;C:\\\\LLLLL\\\\raw.txt&quot;; try&#123; File raw = new File(fileLoc); File modified = new File(&quot;C:\\\\LLLLL\\\\new.txt&quot;); modified.createNewFile(); BufferedWriter out = new BufferedWriter(new FileWriter(modified)); InputStreamReader reader = new InputStreamReader(new FileInputStream(raw)); BufferedReader buffer = new BufferedReader(reader); String line = buffer.readLine(); while(line!=null)&#123; line = line.substring(1, line.indexOf(&quot;\\t&quot;, 1)); out.write(line+&quot;,&quot;); // \\r\\n即为换行 out.flush(); // 把缓存区内容压入文件 line = buffer.readLine(); &#125; out.close(); // 最后记得关闭文件 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void doObjectContent()&#123; String fileLoc = &quot;C:\\\\LLLLL\\\\uft_sfuturedeal.object&quot;; String resource = &quot;C:\\\\LLLLL\\\\raw.txt&quot;; try&#123; File raw = new File(resource); File modified = new File(fileLoc); InputStreamReader reader = new InputStreamReader(new FileInputStream(raw)); BufferedReader buffer = new BufferedReader(reader); String line = buffer.readLine(); BufferedWriter out = new BufferedWriter(new OutputStreamWriter( new FileOutputStream(modified, true))); while(line!=null)&#123; out.write(&quot;&lt;properties id=\\&quot;&quot; + line + &quot;\\&quot;/&gt;\\r\\n&quot;); // \\r\\n即为换行 out.flush(); // 把缓存区内容压入文件 line = buffer.readLine(); &#125; out.close(); // 最后记得关闭文件 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; doSegmentName();// doObjectContent(); &#125;&#125;"},{"title":"JSP页面注意事项","date":"2017-07-11T09:32:05.000Z","updated":"2021-10-28T08:03:23.554Z","comments":true,"path":"archive/JSP页面注意事项.html","permalink":"https://zengzengyu.com/archive/JSP%E9%A1%B5%E9%9D%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html","excerpt":"","text":"在开发网站时，可以用jsp来生成需要进行交互的页面，此时需要在JSP开头添加以下两行代码： 12&lt;%@page isELIgnored=&quot;false&quot;%&gt;&lt;%@page pageEncoding=&quot;UTF-8&quot;%&gt; 第一行表示启用 EL 表达式，比如在 Spring 中利用 model.addAttribute 来让 Java 与 JSP 交互，JSP 内的 ${name} 就会被作为一个表达式对待，如果不加上第一行就会被当成文本。第二行是解决由于 JSP 默认编码导致的网页中文乱码。另外，如果需要使用 JavaScript 则需要将 js 文件放在 webapp 目录下而不是 WEB-INF 下，例如当前页面 test.jsp 的文件层次为 /webapp/WEB-INF/views/test.jsp，需要引用在 /webapp/js/ 下的 JavaScript 文件，则如此引用：&lt;script type=&quot;text/javascript&quot; src=&quot;../../jsfile/jquery-3.2.1.js&quot; /&gt;。"},{"title":"Mybatis 学习笔记","date":"2017-07-08T15:02:27.000Z","updated":"2021-10-28T08:03:23.554Z","comments":true,"path":"archive/Mybatis-学习笔记.html","permalink":"https://zengzengyu.com/archive/Mybatis-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。","text":"MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 完成基本的获取数据操作Mybatis 可以通过 XML 文件快捷地创建 SqlSessionFactory，所以我们先配置 XML 文件可以方便之后对于数据库的操作，下面是一个 config.xml 文件的模板。 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTDConfig 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;properties&gt; &lt;property name=&quot;username&quot; value=&quot;USERNAME&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;PASSWORD&quot;/&gt; &lt;/properties&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://myserver.com/users&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;main/data/user-mapping.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 当中“driver”需要在 Maven 中配置为： 12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt; 为了对数据库进行远程连接，需要对服务端的数据库进行用户权限设置。我在服务端使用的是 MySql，所有 IP(%) 的远程访问都允许，以下是设置代码： 123GRANT ALL PRIVILEGES ON users.* TO &#x27;USERNAME&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;PASSWORD&#x27; WITH GRANT OPTION; 完成设置之后，便可以对远程服务端的数据库进行访问。 另外，Mybatis 还提供 SQL 语句从 XML 到 JAVA 的映射，在 mybatis-config.xml，也就是上面的 XML 文件内，&lt;mapper resource=&quot;main/data/user-mapping.xml&quot;/&gt;已经指出了所引用的映射定义文件。映射定义 XML 文件大致结构如下： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectDriver&quot; resultType=&quot;com.example.beans.customer&quot;&gt; select car_plate,mobile_number,name from driver &lt;/select&gt;&lt;/mapper&gt; 当中的 resultType 是 JavaBean，需要预先定义好。Mybatis 对字段名是全匹配处理，例如表内有字段名为“serial_number”的话，在 JavaBean 内也需要将变量名设置为一模一样的“serial_number”，什么“Serial_Number”，“serialNumber”都不可以，会无法将结果集写进去。 在 Java 代码内对从 SqlSessionFactory.openSession() 获取的 SQL Session 进行操作，这样就完成了最基本的从数据库获取数据的任务。"},{"title":"SQL 笔记","date":"2016-08-26T05:48:37.000Z","updated":"2021-10-28T08:03:23.554Z","comments":true,"path":"archive/SQL-笔记.html","permalink":"https://zengzengyu.com/archive/SQL-%E7%AC%94%E8%AE%B0.html","excerpt":"这篇文章主要内容是关于 SQL 语句的, 因为现在做的项目主要就是从网页端操作数据库的东西, 所以要补一补了.","text":"这篇文章主要内容是关于 SQL 语句的, 因为现在做的项目主要就是从网页端操作数据库的东西, 所以要补一补了. limit1SELECT * FROM db_pub LIMIT start_row, page_size; 以上的 SQL 语句用到了 limit, 它的作用就是从结果集中以 [start_row, page_size] 再筛一遍, 通常配合 ORDER BY 使用. 在网页端主要是帮助分页获取数据."},{"title":"Velocity 学习笔记","date":"2016-08-22T11:32:20.000Z","updated":"2021-10-28T08:03:23.554Z","comments":true,"path":"archive/Velocity-学习笔记.html","permalink":"https://zengzengyu.com/archive/Velocity-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"Velocity 是一个类似于 Jsp 的语言, 可以在布局文件中嵌入 HTML 标签来绘制前端. 并且还能执行一些简单的脚本. 文件类型为 *.vm .","text":"Velocity 是一个类似于 Jsp 的语言, 可以在布局文件中嵌入 HTML 标签来绘制前端. 并且还能执行一些简单的脚本. 文件类型为 *.vm . 注释 Velocity 的注释分为两种, 单行注释以 ## 打头, 多行注释为 #* blablabla *#, 也就是用 # 代替了 /. 引用 Velocity 的引用分为三种: 变量, 属性, 方法. 有关引用的所有参数都被处理为了 String. 而显式的引用方式为加大括号, 例如 ${foo}. 还有一个引用方式为 “安静引用”, 即让变量初始值为空, 例子为 $!foo 或 $!&#123;foo&#125;. 而如果碰到需要使用和变量名相同的字符串时, 可以用反斜杠来转义, 例如 \\foo. 变量Velocity 的变量使用其实就是引用, 从而将动态内容嵌入页面中. VTL, 即为”Velocity 模板语言”. 1#set( $foo = &quot;Velocity&quot; ) 这就是一条典型的 VTL 语句. 对于 Velocity 来说, 所有的变量类型都为 String. 此处变量名为 foo, 而值被赋予之后, 即可使用了: 123456&lt;html&gt;&lt;body&gt;#set( $foo = &quot;Velocity&quot; )Hello $foo World!&lt;/body&gt;&lt;html&gt; 有一点要注意的是, VTL 的变量名必须以字母开头. 属性因为 VTL 是与 Java 交互的, 很显然, 既然变量是引用对象, 自然就有属性这一说法, 例如 $Employee.name. 属性包括对象里的数据和方法. 方法也就是函数啦, 下面是一些实例: 1234$customer.getAddress()$purchase.getTotal()$page.setTitle( &quot;My Home Page&quot; )$person.setAttributes( [&quot;Strange&quot;, &quot;Weird&quot;, &quot;Excited&quot;] ) 传参方式有点像 Json. 与 Java 交互 VTL 使用的数据类型也是 JavaBean, 下面是一个实例: 123456789101112131415$foo $foo.getBar()## is the same as$foo.Bar $data.getUser(&quot;jon&quot;)## is the same as$data.User(&quot;jon&quot;) $data.getRequest().getServerName()## is the same as$data.Request.ServerName## is the same as$&#123;data.Request.ServerName&#125; 而从 Java 向 Velocity 传参时, 则使用 ModelMap: 123456@RequestMapping(&quot;/test/test&quot;) public void test(ModelMap modelMap)&#123; test = new ConnectTestDTO(); test.setRemark(&quot;test&quot;); modelMap.put(&quot;foo&quot;, test); &#125; 此时则向 model 中放入了键为 foo, 值为 test 的 ConnectTestDTO 对象. 指令 VTL 里的指令也就相当于是内置函数了, 以下是几个常见指令: #set没什么可说的, 也就是给变量赋值, 下面是一些实例: 1234567891011#set( $monkey = $bill ) ## variable reference#set( $monkey.Friend = &quot;monica&quot; ) ## string literal#set( $monkey.Blame = $whitehouse.Leak ) ## property reference#set( $monkey.Plan = $spindoctor.weave($web) ) ## method reference#set( $monkey.Number = 123 ) ##number literal#set( $monkey.Say = [&quot;Not&quot;, $my, &quot;fault&quot;] ) ## ArrayList#set( $value = $foo + 1 )#set( $value = $bar - 1 )#set( $value = $foo * $bar )#set( $value = $foo / $bar ) 有一个很坑的地方是, 如果赋值语句的右值为空(null), 而左值之前已经被赋了其他值, 此时赋值语句并不会让左值的数据改变, 依然是原来的值(妈的智障). 当右值被双引号包围时, 会解析里面的变量名, 而单引号则直接引用, 如下: 12345678910111213141516#set( $directoryRoot = &quot;www&quot; )#set( $templateName = &quot;index.vm&quot; )#set( $template = &quot;$directoryRoot/$templateName&quot; )$template#set( $foo = &quot;bar&quot; )$foo#set( $blargh = &#x27;$foo&#x27; )$blarghoutput:## templatewww/index.vm## foo Bar## blargh$foo #if, #foreach就跟字面意思一样, 一个是条件判断, 一个是循环. 和 #set 不同, 这俩都需要用 #end 来标示代码段的结束. 当然, 在条件判断处也支持逻辑符号使用. 12345678910111213141516#set( $criteria = [&quot;name&quot;, &quot;address&quot;] ) #foreach( $criterion in $criteria ) #set( $result = false ) #set( $result = $query.criteria($criterion) ) #if( some_condition &amp;&amp; other_condition || !some_condition ) Query was successful #elseif( some_else_condition ) ## don&#x27;t mind, this is just a demo, lol. blablabla #else blablabla #end #end #include, #parse, #stop#include 就是来引入文件的啦, 可以引入多个文件, like this: #include( &quot;greetings.txt&quot;, $seasonalstock ), 而 #parse 则只能有一个参数, like this: #parse( &quot;me.vm&quot; ). #parse 的用处嘛, 就是宏展开啊. 1234Count down.#set( $count = 8 )#parse( &quot;parsefoo.vm&quot; )All done with dofoo.vm! parsefoo.vm: 1234567$count#set( $count = $count - 1 )#if( $count &gt; 0 ) #parse( &quot;parsefoo.vm&quot; )#else All done with parsefoo.vm!#end #stop 则是调试用的(Oooo~, 在这停顿!). #macro类似于汇编的宏, 跟 #parse 差不多, 一个是引用文件外的, 一个是引用文件内的. 代码段结尾需要 #end 标示. 1234567891011121314151617181920#macro( d )&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;#end#macro( tablerows $color $somelist )#foreach( $something in $somelist ) &lt;tr&gt;&lt;td bgcolor=$color&gt;$something&lt;/td&gt;&lt;/tr&gt;#end#end## call d:#d()## call tablerows:#set( $greatlakes = [&quot;Superior&quot;,&quot;Michigan&quot;,&quot;Huron&quot;,&quot;Erie&quot;,&quot;Ontario&quot;] )#set( $color = &quot;blue&quot; )&lt;table&gt; #tablerows( $color $greatlakes )&lt;/table&gt;"},{"title":"database-and-instance","date":"2016-08-17T06:30:28.000Z","updated":"2021-10-28T08:03:23.554Z","comments":true,"path":"archive/database-and-instance.html","permalink":"https://zengzengyu.com/archive/database-and-instance.html","excerpt":"","text":"完整的数据库所谓完整的数据库, 包括着数据库(database)和实例(instance). 其中 database 为物理上的数据集, 即磁盘或文件. 而 instance 为一组进程或线程与一个共享内存区, 并且内存区可以与系统内其他程序共享. 也即, instance 就是扮演操作 database 的角色. 而这二者的关系就是, 一个数据库可以被多个实例操作, 而一个实例的生命周期内只能装载和打开一个数据库."},{"title":"独立生活的开始","date":"2016-07-22T06:34:36.000Z","updated":"2021-10-28T08:03:23.555Z","comments":true,"path":"archive/first-day-on-my-own.html","permalink":"https://zengzengyu.com/archive/first-day-on-my-own.html","excerpt":"我现在正一步一步地走向社会，说实话，感觉不是很好。要不是有爸妈之前给我赞助的钱，我连租房子都够呛。现在也只能给自己灌灌鸡汤。加油加油，尽力活下去吧。","text":"我现在正一步一步地走向社会，说实话，感觉不是很好。要不是有爸妈之前给我赞助的钱，我连租房子都够呛。现在也只能给自己灌灌鸡汤。加油加油，尽力活下去吧。 租房其实我在杭州的租房还算顺利，在杭州的第一夜有一个学长收留了我。但是房租是押一付三，直接 ￥5200 就没了，还有各种生活必需品买下来，第一天就花了小 ￥6000，更惨的是现在租的房子是第一层，所以到处都是蚊子，蚊香也不顶用，彻底被掏空……支付宝还剩不到四百块，下个月末才发工资，我现在有点慌…… 工作至于工作，现在我还是处于盲流状态，没有暂住证，没有工卡，连出门上个厕所都要找旁边的哥们借卡来刷门禁……不过坐在我旁边的同事陈凡很 nice，是个重庆小哥，一开始就很热情地跟我搭话。老大叫吴加伦，前几天知道我没房子住的时候直接在 qq 群里喊话让大家帮我找找房源。坐在我对面的是个台湾小哥，从台湾成大过来实习，大老远的，下周他就要走了 XD。不过能跟我讲上闽南话他也开心的不行。 生活杭州说实话啊……生活成本太高了，连一瓶可乐特么的都要 ￥3.8，早上肚子饿跑下去买了两根香蕉五块钱就没了。本来想在租来的房子里自己做饭，不过照这么看，可能去外面吃还比自己做饭便宜。妹子再过几天就要来了，但是我连对房子里扎堆的蚊子都毫无办法……嘤嘤嘤。"},{"title":"","date":"2021-10-28T08:03:23.552Z","updated":"2021-10-28T08:03:23.552Z","comments":true,"path":"404.html","permalink":"https://zengzengyu.com/404.html","excerpt":"","text":""},{"title":"实习培训所感","date":"2016-07-26T00:23:04.000Z","updated":"2021-10-28T08:03:23.554Z","comments":true,"path":"archive/feeling-about-internship-s-training.html","permalink":"https://zengzengyu.com/archive/feeling-about-internship-s-training.html","excerpt":"在恒生的实习到现在也不算正式开始吧，还在实习培训中。总计四天的培训，我就尽力把这些经历按天记录下来。","text":"在恒生的实习到现在也不算正式开始吧，还在实习培训中。总计四天的培训，我就尽力把这些经历按天记录下来。 第一天说实话，这种公司从我知道有打卡制度之后就没想着能有多’interesting’的心态演讲，果不其然，一开始就灌鸡汤，XX应届生在多年摸爬滚打疯狂加班后成为了一个四百多人部门的头头，23333.至于之后的金融知识介绍，我一开始还算有兴趣，可是到后来也就是名词解释而已……第二天的主要内容也是金融知识的概要介绍，我觉得，啊，也没啥可期待的。 第二天比起昨天比较泛的介绍，今天是具体化到证券的知识。其实也就那样吧……解释下一、二级市场，也即发行、交易市场。还有融资融券什么的，此处的’融’就是借。"},{"title":"categories","date":"2016-08-10T12:07:34.000Z","updated":"2021-10-28T08:03:23.555Z","comments":true,"path":"categories/index.html","permalink":"https://zengzengyu.com/categories/index.html","excerpt":"","text":""},{"title":"servlet学习笔记","date":"2016-08-11T02:44:19.000Z","updated":"2021-10-28T08:03:23.555Z","comments":true,"path":"archive/servlet学习笔记.html","permalink":"https://zengzengyu.com/archive/servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"现在想开始上手网页开发，才发现之前都没接触过那些基础的东西。没办法，从头开始吧。","text":"现在想开始上手网页开发，才发现之前都没接触过那些基础的东西。没办法，从头开始吧。 什么是 servlet servlet 是一个 Java 的类, 继承自 HttpServlet 类, 在服务端运行用以处理客户端的请求. 其实就是一个 server 和 database 的中间层. servlet 生命周期 servlet 的一个生命周期实例: 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。 Servlet 容器在调用 service() 方法之前加载 Servlet。 然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。 所以, servlet 大体的生命周期为: 调用 init() 进行初始化. 调用 service() 方法来处理客户端请求. 调用 destroy() 结束. 由 JVM 进行垃圾回收. init() 方法该方法被设计为只能调用一次, 用于一次性的初始化. servlet 创建于用户第一次调用对应于该 servlet 对应的 URL 时, 用户可自定义让 servlet 在服务器启动时即初始化. 用户第一次调用 servlet 时就会创建一个实例, 每一个用户请求都会产生一个新的线程, 适当的时候移交给 doGet 或 doPost 方法. init 方法简单地创建并初始化一些数据, 存在于整个 servlet 的生命周期. 123public void init() throws ServletException &#123; // 初始化代码...&#125; service() 方法service() 方法是执行实际任务的主要方法. Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求, 并把格式化的响应写回给客户端.每次服务器接收到一个 Servlet 请求时, 服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型(GET、POST、PUT、DELETE 等), 并在适当的时候调用 doGet, doPost, doPut, doDelete 等方法。下面是该方法的特征 1234public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException&#123;&#125; service() 方法由容器调用, service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法. 所以不用对 service() 方法做任何动作, 只需要根据来自客户端的请求类型来重载 doGet() 或 doPost() 即可.doGet() 和 doPost() 方法是每次服务请求中最常用的方法. 下面是这两种方法的特征. doGet() 方法GET 请求来自于一个 URL 的正常请求, 或者来自于一个未指定 METHOD 的 HTML 表单, 它由 doGet() 方法处理. 12345public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码&#125; doPost() 方法POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单, 它由 doPost() 方法处理. 12345public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码&#125; destroy() 方法destroy() 方法只会被调用一次, 在 Servlet 生命周期结束时被调用. destroy() 方法可以让 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动.在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示： 123public void destroy() &#123; // 终止化代码...&#125; 实例 Hello World!servlet 的 HelloWorld.java 123456789101112131415161718192021222324252627282930313233// 导入必需的 java 库import java.io.*;import javax.servlet.*;import javax.servlet.http.*;// 扩展 HttpServlet 类public class HelloWorld extends HttpServlet &#123; private String message; public void init() throws ServletException &#123; // 执行必需的初始化 message = &quot;Hello World&quot;; &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置响应内容类型 response.setContentType(&quot;text/html&quot;); // 实际的逻辑是在这里 PrintWriter out = response.getWriter(); out.println(&quot;&lt;h1&gt;&quot; + message + &quot;&lt;/h1&gt;&quot;); &#125; public void destroy() &#123; // 什么也不做 &#125;&#125; 生成 HelloWorld.class 后放入 webapps/ROOT/WEB-INF/classes.并在 WEB-INF 目录下的 web.xml 添加如下内容: 12345678910111213&lt;web-app&gt; ... &lt;servlet&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ...&lt;/web-app&gt; 即可运行该 demo. POST &amp; GET &amp; TABLES//TODO"},{"title":"Spring MVC 学习笔记","date":"2016-08-09T12:20:38.000Z","updated":"2021-10-28T08:03:23.554Z","comments":true,"path":"archive/about-spring-mvc.html","permalink":"https://zengzengyu.com/archive/about-spring-mvc.html","excerpt":"其实我现在学习的 Spring MVC 并不是原生的，而是公司魔改版本的 JRES 系列框架。里面的坑之多简直丧心病狂。首先就是配置工程。公司里使用的 IDE 为 Eclipse LUNA，JDK 版本为 1.7。","text":"其实我现在学习的 Spring MVC 并不是原生的，而是公司魔改版本的 JRES 系列框架。里面的坑之多简直丧心病狂。首先就是配置工程。公司里使用的 IDE 为 Eclipse LUNA，JDK 版本为 1.7。 初始化工程工程的初始化选择为 Maven Project，不过在创立工程前应进入 Window-&gt;Preference-&gt;Maven-&gt;User Setting 里面更改 Maven 的 repo 下载地址。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;settings&gt; &lt;localRepository&gt;C:\\Users\\zengzy19585\\.m2\\repository&lt;/localRepository&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;!--This sends everything else to /public --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://repos.hundsun.com:6060/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--Enable snapshots for the built in central repo to direct --&gt; &lt;!--all requests to nexus via the mirror --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;hundsun-central-repos&lt;/id&gt; &lt;url&gt;http://repos.hundsun.com:6060/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;hundsun-central-repos&lt;/id&gt; &lt;url&gt;http://repos.hundsun.com:6060/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;!--make the profile active all the time --&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;username&gt;readOnly&lt;/username&gt; &lt;password&gt;nexus@0831&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;hsrisk-ftp&lt;/id&gt; &lt;username&gt;mvn&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;!-- &lt;proxies&gt; &lt;proxy&gt; &lt;id&gt;my-proxy&lt;/id&gt; &lt;active&gt;true&lt;/active&gt; &lt;protocol&gt;http&lt;/protocol&gt; &lt;host&gt;192.168.190.126&lt;/host&gt; &lt;port&gt;3128&lt;/port&gt; &lt;/proxy&gt; &lt;/proxies&gt; --&gt;&lt;/settings&gt; 如此设置好 Maven 的设置之后才能从公司的 repo 获取魔改版本的 Spring 框架。之后需要设置 Maven 工程的依赖，即 pom.xml 设置为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;zt.demo&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;jresplus-remoting.version&gt;1.1.15&lt;/jresplus-remoting.version&gt; &lt;jresplus-mvc.version&gt;1.0.10&lt;/jresplus-mvc.version&gt; &lt;jresplus-ui.version&gt;1.0.28&lt;/jresplus-ui.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hundsun.jresplus&lt;/groupId&gt; &lt;artifactId&gt;jresplus-mvc&lt;/artifactId&gt; &lt;version&gt;$&#123;jresplus-mvc.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hundsun.jresplus&lt;/groupId&gt; &lt;artifactId&gt;jresplus-remoting&lt;/artifactId&gt; &lt;version&gt;$&#123;jresplus-remoting.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.10-FINAL&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.4.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--拼音处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.belerweb&lt;/groupId&gt; &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-configuration&lt;/groupId&gt; &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jdom&lt;/groupId&gt; &lt;artifactId&gt;jdom&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-compress&lt;/artifactId&gt; &lt;version&gt;1.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;configuration&gt; &lt;warSourceDirectory&gt;WebContent&lt;/warSourceDirectory&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 如此设置之后，需要在 webapp/WEB-INF 目录手动建立以下文件夹： WEB-INF/confWEB-INF/conf/springWEB-INF/views/layoutWEB-INF/views/screen 并在 WEB-INF/conf/spring 文件夹下建立 *-beans.xml 文件来进行 Spring 框架的配置。以下为 service-beans.xml 的文件内容： 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot; default-autowire=&quot;byName&quot;&gt; &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;cacheSeconds&quot; value=&quot;5&quot;/&gt; &lt;property name=&quot;useCodeAsDefaultMessage&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 还应在 WEB-INF/conf 下建立 log4j.properties、server.properties、vm-toolbox.xml 配置文件。内容依次为 123456789101112131415161718log4j.propertieslog4j.rootLogger=INFO,stdout,errorfile#standout log appender #log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n#error log appender #log4j.appender.errorfile=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.errorfile.File=$&#123;webapp.root&#125;/logs/error.loglog4j.appender.errorfile.Threshold=ERRORlog4j.appender.errorfile.append=truelog4j.appender.errorfile.ImmediateFlush=truelog4j.appender.errorfile.encoding=UTF-8log4j.appender.errorfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.errorfile.layout.ConversionPattern=[%p] %d %l %m %n 12345678server.propertiessystem.dev.mode=trueapp.server.host=localhost#app.server.host=192.168.224.41app.server.port=8080jres.action.scan=zengzy.test 12345678910111213141516vm-toolbox.xml&lt;?xml version=&quot;1.0&quot;?&gt;&lt;toolbox&gt; &lt;xhtml&gt;true&lt;/xhtml&gt; &lt;tool&gt; &lt;key&gt;stringUtils&lt;/key&gt; &lt;scope&gt;application&lt;/scope&gt; &lt;class&gt;org.apache.commons.lang.StringUtils&lt;/class&gt; &lt;/tool&gt; &lt;tool&gt; &lt;key&gt;dateUtil&lt;/key&gt; &lt;scope&gt;application&lt;/scope&gt; &lt;class&gt;com.hundsun.jresplus.common.util.DateUtil&lt;/class&gt; &lt;/tool&gt;&lt;/toolbox&gt; 至此，基本的框架差不多就搭建完成了。需要注意的是，如果在中文环境下进行程序编写，Eclipse 有可能把字符集选成 gbk，这时候需要到 Window-&gt;Preference-&gt;Workspace 里进行默认字符集的设置，改为 UTF-8。 Hello World因为 Spring 是 MVC 框架（Module，View，Control），而 V 所在的位置是 View/screen/folder，即生成网站之后，访问的视图位于 localhost:8080/Project-Name/folder 之下。对于视图的 *.vm 文件，其实就是类似于 html 语言，比如本次创建的 Hello World 工程，layout 下，创建的 default.vm 内容为： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Layout Test&lt;/h3&gt; ------------------------------------------------- &lt;br/&gt; $screen_content &lt;br/&gt; -------------------------------------------------&lt;/body&gt;&lt;/html&gt; 而之后要部署到 tomcat 上的文件则位于 screen/folder 之下，创建 test.vm 文件。 12345678&lt;h4&gt;中文字符测试&lt;/h4&gt;&lt;form method=&quot;POST&quot; action=&quot;$appServer.get(&#x27;/test/test.htm&#x27;)&quot;&gt; &lt;fieldset&gt; &lt;label&gt;test&lt;/label&gt; &lt;input name=&quot;data&quot;/&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/fieldset&gt;&lt;/form&gt; 在工程的 src 下创建 TestAction.java 文件，扮演 MVC 中 C 的角色。 1234567891011package zengzy.test;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestAction &#123; @RequestMapping(&quot;/test/test.htm&quot;) public void test() &#123; &#125;&#125; 至此，还差最后一步，就是 WEB-INF/ 下的 server.properties 编辑。添加 1jres.action.scan=zengzy.test` 来指定控制器的位置。然后右键 Server 标签页下的 Tomcat，首先 Clean，之后点击 Run，”Hello World！”。 Nginx 与 Tomcat 的混合使用TODO：目前只知道将编写好之后的 Web 项目 Export 为 *.war 包，然后扔到服务器上 Tomcat 目录下的 webapps 文件夹中，访问方式为：domain:8080/war-name/folder/test.htm。folder 即为 WEB-INF/screen/folder。混合 Nginx 与 Tomcat，让 Nginx 进行反向代理仍需学习。 利用 JSON 让 Java 与 JavaScript 交互首先是 Java 后端代码: 12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;/pub/entrust&quot;)public class EntrustQueryController &#123; @Autowired private EntrustServices entrustService; @RequestMapping(&quot;/entrust-query&quot;) public void entrustQuery(ModelMap modelMap, HttpServletRequest request) &#123; modelMap.put(&quot;siteName&quot;, &quot;委托查询|O++交易系统&quot;); &#125; @RequestMapping(value = &quot;/date.json&quot;) @ResponseBody public Map&lt;String, Object&gt; getDateArr(HttpServletRequest request)&#123; EntrustQueryRequest queryRequest = new EntrustQueryRequest(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); queryRequest.setBeginDate(request.getParameter(&quot;startDate&quot;).replace(&quot;-&quot;, &quot;&quot;)); queryRequest.setEndDate(request.getParameter(&quot;endDate&quot;).replace(&quot;-&quot;, &quot;&quot;)); EntrustQueryResponse response = entrustService.entrustQuery(queryRequest); map.put(&quot;tableContent&quot;, response.getRows()); map.put(&quot;rowCount&quot;, response.getRowCount()); return map; &#125;&#125; 然后是 JavaScript 前端代码: 1234567891011121314151617$(&quot;#query&quot;).click(function()&#123; var startDate = $(&quot;input[name=&#x27;startDate&#x27;]&quot;).val(); var endDate = $(&quot;input[name=&#x27;endDate&#x27;]&quot;).val(); var dateArr = startDate &gt; endDate ? [endDate, startDate] : [startDate, endDate]; $.post(&quot;$&#123;appServer&#125;/pub/entrust/date.json&quot;, &#123; startDate: dateArr[0], endDate: dateArr[1] &#125;, function(data)&#123; for(var i = 0; i &lt; data.rowCount; i++)&#123; //actions &#125; &#125; ); //actions &#125; 说的简单点, 就是 JavaScript 利用 JQuery 的 $.post 方法与后端的 Java 交互, Java 向前端发参数时需要在法参数的函数上加个 @ResponseBody, 否则 JavaScript 获取参数会遇到 404."},{"title":"关于私募和我所在的部门","date":"2016-08-01T10:52:36.000Z","updated":"2021-10-28T08:03:23.555Z","comments":true,"path":"archive/private-placement-and-oplus.html","permalink":"https://zengzengyu.com/archive/private-placement-and-oplus.html","excerpt":"在经过并没什么卵用的五天大众培训后，又开始了一轮部门内的专门培训。今天的主要内容是关于私募行业的知识和部门的简介。","text":"在经过并没什么卵用的五天大众培训后，又开始了一轮部门内的专门培训。今天的主要内容是关于私募行业的知识和部门的简介。 私募其实私募的特点也就这么几个： 合格投资人 个人高占比 高门槛 锁定期（First year lock in） 定期赎回 2/20 收益 所在部门（OPLUS）这个部门主要是为了私募服务。"},{"title":"公司自用工具踩坑记录","date":"2016-08-23T12:07:25.000Z","updated":"2021-10-28T08:03:23.555Z","comments":true,"path":"archive/公司自用工具踩坑记录.html","permalink":"https://zengzengyu.com/archive/%E5%85%AC%E5%8F%B8%E8%87%AA%E7%94%A8%E5%B7%A5%E5%85%B7%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html","excerpt":"恒生用的系统大部分都是自己魔改过的东西, 比如从网页端操作数据库就需要先调用公司的网页框架 Jres, 将数据(包括请求的参数和要调用的功能号)通过 Filter 封装以后, 以 T2 协议向数据库中间件 Cres 发送. Cres 接收之后进行解包, 依据功能号调用对应的功能, 并将接收到的参数进行入参. 而 Cres 上的功能则由 Ares 编写. Ares 是一款 IDE, 代码编写主要是通过宏定义的伪代码, 然后拼接成 C++ 程序, 再用 NetBeans 传上服务器编译为 *.so 文件. 在服务器上修改 *_ar.xml 和 *_ls.xml 来对特定功能号的 component 进行路由规则制定和添加处理模块. 实习期间应该都会一直更新.","text":"恒生用的系统大部分都是自己魔改过的东西, 比如从网页端操作数据库就需要先调用公司的网页框架 Jres, 将数据(包括请求的参数和要调用的功能号)通过 Filter 封装以后, 以 T2 协议向数据库中间件 Cres 发送. Cres 接收之后进行解包, 依据功能号调用对应的功能, 并将接收到的参数进行入参. 而 Cres 上的功能则由 Ares 编写. Ares 是一款 IDE, 代码编写主要是通过宏定义的伪代码, 然后拼接成 C++ 程序, 再用 NetBeans 传上服务器编译为 *.so 文件. 在服务器上修改 *_ar.xml 和 *_ls.xml 来对特定功能号的 component 进行路由规则制定和添加处理模块. 实习期间应该都会一直更新. Ares 方面 变量名未定义伪代码的问题, 因为是用类似于 [结果集语句][select * from t_demo][t_demo] 这种宏定义的东西拼接成 C 语言代码, 所以很容易出现变量名未定义的 Bug, 没办法, 只能慢慢看. 接口接口定义的参数分为三种: 标准字段, 对象类型, 参数组. 标准字段就是数据库的字段类型. 对象类型需要自己定义, 类似于 JavaBean, 里面包含的是标准字段, 通常将对象类型名取为 rows. 参数组类似于标准字段, 是规定了包含什么参数的一组字段. 如果是查询功能的话, 需要打开[返回结果集]功能, 就是 ResultSet. Cres 方面 更改不生效在从 NetBeans 上传源码并编译为 *.so 文件之后, 需要对 pub 进行重启, 否则无法调用更改后的功能. Jres 方面 返回结果集解包这个东西坑了我差不多一天… 接口定义的返回参数中, 标准字段对应的要么是 char, 要么是 Integer, 这些可以从其他代码中获知. 如果接口定义的返回参数多于一个, 就需要用 *DTO(extends BaseDTO) 来接收, 而如果是 rows 这种对象类型, 则对应的类型是 List. 比如我要查询的东西返回内容是: 123456row_count;rows[func_id, func_name, remark];ConnectTestDTO:Integer func_id;String func_name, remark; 则对应的接收 DTO 应为: 12Integer rowCount;List&lt;ConnectTestDTO&gt; rows; 在 Java 中定义的变量名与 Ares 中的标准字段名对应是用驼峰替代下划线, 如 funcName -&gt; func_name."},{"title":"我的大学","date":"2016-12-28T01:52:26.000Z","updated":"2021-10-28T08:03:23.555Z","comments":true,"path":"archive/我的大学.html","permalink":"https://zengzengyu.com/archive/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6.html","excerpt":"所以, 当我提交了毕业设计的申请表之后, 我突然意识到: 我的大学生活, 已经要结束了.","text":"所以, 当我提交了毕业设计的申请表之后, 我突然意识到: 我的大学生活, 已经要结束了. 2013 还记得大一那会儿, 不论是军训期间还是学期中时不时在东区大礼堂举办的讲座, 都让我对科大充满着自豪与认同感, 天天在空间刷”穷清华, 富北大, 不要命的上科大”. 抱着本烂大街的”吉米多维奇”在图书馆钻研, 看大神们在贴吧说”微积分 90 以上很容易的”, 然后想, 我也行吧? 在国庆的时候去了趟南京, 失魂落魄地回来, 连行李袋都落在地铁了. 还有闻名 13 级物院的学渣寝室, 手残却坚持玩 dota 的熊大神. 也是熊大神, 他那个震天响的呼噜第一次让我感受到了群居生活的可怖. 在卧谈会吹牛逼, 听马贵祥说他的三个前女友, 我们其他三个人在被窝吓得瑟瑟发抖不敢说话; 听学神王昕说他在高中是怎么虐人的; 听熊神说他老家在黄土高坡的露天厕所, 和被他称为”QQ小号”的女朋友. 而我呢, 一想也没啥好说的, 就张开了想象的翅膀, 编出我认为的完美的高中生活. 通过班赛认识了好多人, 也实现了我高中的愿望: 天天打篮球. 我大学生活好像进行地很完美, 除了一学期没跟女生说过一句话. 然后, 第一次期末考就来了. 2014 五教是我最喜欢的自习场所, 除了人少和环境通透, 网还快啊. 第一次见到了雪, 开心地拍下雪景发给喜欢的人, 满怀期待地等着回应. 看着郭沫若广场的小朋友, 天天玩”他们是我们学长吧”的梗. 期末考我觉得还行, 题目都会做, 不过”我跪了”的动态还是要在空间发一发的, 装装弱说不定还能骗到请客呢. 回家, 躺尸, 跟风发高中照片怀念一下, 补 COD 系列. 然后, 出分了. 13 级的物院狗都记得的历年微积分优秀率最低的恐惧. 讲道理, 我看到总评的第一反应是: 我考卷被改错了吧? 还跟微积分老师在邮件里吵起来. 接着力学也出分了. 之后就在考虑我到底适不适合这个专业了哈哈哈, 得亏我那时候心态还没崩, 各种找学长, 刷贴吧知乎, 寻找解决的办法. 就是在那个时候, CS 这个专业犹如天神下凡, 各种高起薪与低门槛, 撩的我心痒. 但是心里还是有点傲气的, 从排第一的物理专业转到不出名的计算机专业, 我心有不甘, 大部分水土不服却坚持不从物院转出来的同学不外乎也抱着这种想法. 那段时间我很迷茫, 因为我对物理真的不感兴趣, 却又放不下它背后那种看似光明的前路. 还好在深夜里有人陪着我, 什么开心的不开心的都可以分享, 让我熬过了那段时间, 也下定决心, 为她转专业——很搞笑吧. 还在打电话的时候用便条提前写话题点, 跟做 presentation 似的, 哈哈. 当时对外宣称的理由是我很喜欢计算机, 时过境迁, 终于可以吐露真相了. 反正我是决定了, 所以那学期也拼了命地学习, 想着至少刷上转院所需要的 gpa 再说. 除了数学和物理, 那学期的其他学科总评也都上了 85. 热学依然是搞笑的 60 分. 心里狂跳着, 在教务系统里确认了转院的请求, 过了一周就收到了转院面试的预约邮件. 那应该是我第一次面试, 贼紧张, 在准备室里狂看面试宝典, 担心面试过不了的话我岂不是跟狗一样了. 结果面试就是唠家常, 哈哈哈哈, 现在想起来还是觉得好笑, 我进去的时候脸憋得通红, 我之后在计院的班主任连忙安慰我别紧张, 还给我递水喝. 顺理成章地收到了转院成功的通知邮件, 那时候我的心里突然就充满了对未来的希望, 不论是工作还是其他. 现在想起来, 还真是人生如戏, 之前的美好全是之后痛苦的铺垫. 这个暑假, 估计是我最纠结的暑假了. 为了跟那时候的小女友一起玩, 就想着自己买票瞒着爹妈先回去, 可是钱又不够买高铁票——那就绿皮走起! 我也是心大, 对二十多个小时的绿皮没啥概念, 拎着桶泡面就上火车了. 然后碰到了想跟我换下铺的女人, 我一看上铺那么窄果断拒绝, 结果丫把行李往我床上一扔直接吵了起来, 隔三差五就来闹, 找乘务员也没用, 我不堪其吵只好让了下铺. 绿皮火车的热水还只有六十多度的样子, 泡面都泡不开, 夜里车轮咣当咣当地响, 压根睡不着, 基本是熬了个通宵. 但我那时候也没有很不开心, 毕竟就快要跟小女友没羞没躁地在一起了. 可是快到厦门之后, 我又开始纠结了: 我那时候为了期末考各种通宵, 脸上满是红红的痘, 接近于毁容的状态, 到底该不该去找她. 剩下的也没啥好写的了, 谈恋爱嘛都那样, 该逛街逛街, 该吃饭吃饭. 暑假结束后, 我就正式从物院转到计院了, 开始忙起了各种事, 递表格, 个性化选课补上计院大一的课, 找宿管搬宿舍, 两个校区来回跑, 忙活了一个多月. 然后就发现, 课怎么那么那么那么多. 刚搬到新校区, 一切都要重新适应, 连同班同学都认不全, 想找人帮个忙也没法开口, 女友因为一个多月没怎么联系, 变成了前女友. 我接着就兵荒马乱了啊, 感觉自己基本失去了一切了啊, 一个人在一个新校区默默努力着活下去. 在这里我要感谢篮球, 是篮球让我在计院重新认识了不少好朋友, 虽然很多篮球队的壮士现在都沦为了网吧选手, 我也沦为了办公室选手. 不论是我在计院认识的第一个朋友张子越, 还是陪我健身的范兴鹏, 让我抱大腿的华神彤神, 跟我通宵的赵博坤, 真的非常非常感谢他们, 上天眷顾我, 还让我有了一个好妹子——但这些都是大半年后发生的事. 不但认识不到新的朋友, 还有繁重的课业压力, 这学期的绩点也是我大学生涯中最低的一学期, 还好没有挂科. 在极度焦虑中度过了我计院的第一个学期后, 我开始服用抗抑郁药物了. 2015 要问我为什么从一个对科大有认同感的人变成了一个科大黑, 看看我的变化就行了: 我以前是一个猥琐而开朗的人, 可以跟滴滴司机从暂住证扯到汤包真好吃. 然后? 我有个亲戚对我说, 你怎么老是不说话. 是啊, 我能说啥, 回忆局限在了高中, 社团一学期就一两次活动, 同学要么打撸要么自习, 见面就”大神好厉害”, 话题永远绕不开”gpa”和”我想去嫖娼”, 每年都有因为”安静的书桌”被骗进来的萌新. 我真的, 真的, 不想变成这样子. 这一年我生活的重心转移到了实习上, 还好之前进了实验室, 混了趟微软的经历, 也没有在”唯gpa论”中放弃, 终于找到了个国外交流项目. 一切好像都在开始变好, 有了朋友, 有了妹子, 但我在学校里依然开心不起来. 2016"},{"title":"项目理解","date":"2016-08-11T10:51:24.000Z","updated":"2021-10-28T08:03:23.555Z","comments":true,"path":"archive/项目理解.html","permalink":"https://zengzengyu.com/archive/%E9%A1%B9%E7%9B%AE%E7%90%86%E8%A7%A3.html","excerpt":"本次实习项目为实现一个迷你的股票交易系统. 以下为对本次项目的一些理解.","text":"本次实习项目为实现一个迷你的股票交易系统. 以下为对本次项目的一些理解. 概要 后端采用 MySQL 为数据库, 使用公司开发的 IDE Ares 对后端代码进行部署. Web 端 登录 资金帐号维护 增删改查、包含通道、资金持仓同步 风控设置 黑白池设置 风控设置 双十, 即股票持有量和价值分别不超过该股票的总量和总净值的 10%. 指令管理 单产品指令 包含资产面板、持仓、指令下达面板，下达指令时需要判风控，可用，不包含审批，5档行情可以考虑不做，指令下达自动分发到一个固定交易员. 指令管理 指令列表、指令明细，有撤单功能. 报表查询 委托查询，包含查历史. 日终 归档：证券信息、委托、成交、持仓、流水归档. 切换业务日期. C# 端 登录 使用HSID模拟登录 指令交易 待执行指令列表、指令下单面板、指令委托、指令成交. 证券交易 资金面板、下单面板、持仓列表、委托、成交列表. 报盘轮询读取数据库，发送到柜台."},{"title":"about","date":"2016-08-10T12:06:38.000Z","updated":"2021-10-28T08:03:23.553Z","comments":true,"path":"about/index.html","permalink":"https://zengzengyu.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-08-10T09:24:51.000Z","updated":"2021-10-28T08:03:23.556Z","comments":true,"path":"tags/index.html","permalink":"https://zengzengyu.com/tags/index.html","excerpt":"","text":""},{"title":"ubuntu命令行源代理设置","date":"2016-08-02T14:09:53.000Z","updated":"2021-10-28T08:03:23.555Z","comments":true,"path":"archive/ubuntu命令行源代理设置.html","permalink":"https://zengzengyu.com/archive/ubuntu%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BA%90%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE.html","excerpt":"","text":"使用科学上网工具时,因为在 linux 下不能直接在 shadowsocks 的 gui 里直接设置全局代理,需要在浏览器中添加代理插件走 localhost:1080,这样有点麻烦.在 Ubuntu 里的 Terminal 里如果要用代理来翻墙 apt-get, 可以使用: 1http_proxy=http://10.1.3.1:8080 apt-get update 来用代理进行下载.在文件 /etc/environment 中,是存储系统变量的地方,可以在这里设置其他的东西.ubuntu 环境变量设置之后即可."}],"posts":[{"title":"game_and_education","slug":"game-and-education","date":"2021-10-28T08:34:14.000Z","updated":"2021-10-28T08:34:41.925Z","comments":true,"path":"2021/game-and-education/","link":"","permalink":"https://zengzengyu.com/2021/game-and-education/","excerpt":"","text":"游戏与教育看到我的堂弟现在的情况，我忍不住思考，作为一个父亲，关于孩子的教育到底应该怎么做。 我的学生时代我曾经也是一个长辈眼里「要操心」的孩子，当时的确也经历过一些叛逆期，在那个时候，我的心里更期待的是什么，到底要的是什么。 我高三之前的学生生活，应该可以概括为「算是优秀，但不是顶尖」那一类学生。本来老师安排我坐在第三排，但是在课堂上，我偶尔会因为想睡觉而直接坐到最后一排，老师睁一只眼闭一只眼。上物理课的时候，老师也给我开放特权，允许去图书馆自习，我就是在那段时间看完了《三体》三部曲。对于当时的我来说，确实读书的压力不大，更倾向于「能偷懒就偷懒」这种状态。自然也玩游戏、看电视，那个时候电脑和电视机顶盒都被密码锁住，我就发挥想象力，破解密码。 在高三的时候，有一次市质检成绩不是很好。一个我有点讨厌的同学他妈妈看了我的成绩以后，说：「以后能上个厦大就很好啦。」听到这句话以后，我心里就好像被打了一拳。这应该就是我当时心态的转折点，之后对「高考」与「学习」这两个主题有了更深的自驱力。 游戏到底代表什么对于学生来说，他们的工作就是读书、考试。自然而然，这两件事都是枯燥的。就像当时的我，即使因为玩游戏而让父母大发脾气，甚至把电脑都掰断、摔坏，没游戏可玩、没电视可看的情况下，依然会找到其他摸鱼的办法：看小说、找同学借 MP4 看电影。 我爸也是过来人，当时高考前看天龙八部，被爷爷直接把小说给撕了。 所以其实「游戏」更代表着一种逃避的方式，如果没有充足的自驱力，是自发的去学习、想要从高考取得高分，即使禁绝了一切娱乐方式，也只会让孩子把时间花在其他地方，反正就不是学习。 如果游戏实在影响了正常生活，父母规劝的观点是否可以从「会影响你学习」转到「会影响你健康」这方面，反而不那么让孩子反感呢？不得而知，当时我的父母也没有从「影响健康」这方面和我继续谈下去。 自己想要去学习，知道自己是为了什么、不学习会失去什么，才会把时间花在上面，因为「学习」这件事本身就是不快乐的、疲惫的、让人逃避的。 自驱力从何而来对于我来说，从讨厌的人那里听来的「以后能上个厦大就很好啦。」成为了一个楔子，不论是当时「面子」被伤害还是什么，这让我从一个不那么乐观的角度思考我自己的未来。当时我的家庭虽说衣食无忧，但也不是那么的「有面子」，如今已为人父不禁更为当时的想法羞愧。 而现在的生活水平更高，如果父母一辈的生活已经足够「高质量」的话，可能难以让孩子自发的产生「我想要通过高考脱离这里，去一个条件更好的地方」这种朴素的想法，毕竟现在的互联网时代会让人接触到非常多的声音、观点，「学习就是唯一的出路」已经很难在孩子中引发共鸣了。 毕竟孩子也是一个独立的人，不可能让他的一切都按着父母的意发展，父母能做的其实也是有限。想到这里确实有点心酸，我们认为好的东西，他们不一定是认同的，甚至会认为父母控制欲过强。 对于不涉及底线的事情，比如「身体健康」、「违法犯罪」等，引导，而不是强势干预，是不是一个更好的做法？让孩子自发的去做这个事，而不是被推着去做的。这确实说的容易，做的难。除了引导，剩下的也就是为孩子的未来做准备，比如准备一套房吧，哈哈。","categories":[],"tags":[],"keywords":[]},{"title":"图形学笔记","slug":"graphic-note","date":"2021-03-19T15:30:12.000Z","updated":"2021-10-28T08:03:23.553Z","comments":true,"path":"2021/graphic-note/","link":"","permalink":"https://zengzengyu.com/2021/graphic-note/","excerpt":"","text":"光线追踪ray = o + td 平面求交(p - p‘) * N = 0 AABBaxis aligned bounding box xx - intr with ray, t…min x, t…max x;yy - intr with ray, t…min y, t…max y;zz - intr with ray, t…min z, t…max z; accuniform grid（teapot in stadium） oct-treekd-tree//bsp-tree，Binary space partitioning bvh","categories":[],"tags":[],"keywords":[]},{"title":"奇技淫巧-重载malloc抓内存泄漏","slug":"hook_malloc","date":"2021-01-05T08:31:10.000Z","updated":"2021-10-28T08:03:23.553Z","comments":true,"path":"2021/hook_malloc/","link":"","permalink":"https://zengzengyu.com/2021/hook_malloc/","excerpt":"","text":"讲到 memory leak，valgrind 是一个不可能绕过的话题。但是在实际应用中，反而 valgrind 能发现的 leak 基本没有。原因其实挺简单的，valgrind walk heap 的时候，他是不知道哪些是需要一直持有的内存区，哪些才是泄漏的内存区。并且丫的得 attach 上去。 所以才需要一个重载的 malloc、calloc、mmap、free 来记录我们每一次内存分配、释放，由开发者自己来 review 可疑的 leak 点而不是由通用检查程序来替你发现。之前在讲这个重载的时候，有小朋友跟我杠过「你这个东西不能用在 C++，new 和 delete 你没重载到。」。这里就多说一句吧：new 和 delete 虽然经常在面试里被提到，说和 malloc、free 是有区别的，但是其实 malloc 就是 new 的一个部分，free 和 delete 的关系同理。 接下来，让我们一步步的去实现这个有趣的 hook。 内存检测源码 LD_PRELOAD trick这个是一切的基础，所以这个东西才只能在 linux 上实现。LD_PRELOAD 可以让用户在启动进程时指定首先读取的 library，包括 glibc。写过 C/C++ 的话，应该会碰到库冲突的问题，多个动态库里如果有同名的 symbol，进程就会使用先读到的那个动态库里的。这也是 LD_LIBRARY_PATH 折磨人的原因之一。 在我们使用了 LD_PRELOAD 成功重载了 glibc 之后，就可以在自定义的那些 malloc、free 等内存操作中开始记录。 12345678910111213141516171819202122struct MY_HEAD &#123; size_t magic; void* realptr; size_t size;&#125;;#define MY_MAGIC_ALLOC 0x55aa66bb77cc88dd // 已分配内存魔术字#define MY_MAGIC_FREE 0xdd88cc77bb66aa55 // 已释放内存魔数字extern &quot;C&quot; void* malloc(size_t size) &#123; auto rs = sizeof(MY_HEAD) + size; // tmalloc: true malloc auto p = (MY_HEAD *)tmalloc(rs); p-&gt;magic = MY_MAGIC_ALLOC; p-&gt;realptr = p; p-&gt;size = rs; LOG(&quot;alloced [%u] byte&quot;, size); // offset of customized head return (p + 1);&#125; 看到以上代码自然很好理解，我们只是在真正的 malloc 等内存操作外面包了一层皮。但是看到这里，肯定已经有一个疑问：在我们重载了 malloc 之后，真的 malloc 怎么办？ 获取真正的 malloclinux 的系统函数 dlsym 里有一个 RTLD_NEXT 选项，可以让调用者在存在符号冲突时直接获取到下一个符号（也就是函数）的指针。所以我们的代码现在应该是这样。 1234567891011121314151617181920212223242526bool inited = false; // consider atomicvoid __attribute__((constructor)) init() &#123; if (inited) &#123; return; &#125; inited = true; void* (*tmp_malloc)(size_t size); *(void**)(&amp;tmp_malloc) = dlsym(RTLD_NEXT, &quot;malloc&quot;); if (!tmp_malloc) &#123; frintf(stderr, &quot;load function fail %s\\n&quot;, dlerror()); exit(-1); &#125; tmalloc = tmp_malloc;&#125;extern &quot;C&quot; void* malloc(size_t size) &#123; if (!inited) &#123; init(); &#125; // ...&#125; 但是，如果我们开始运行这段代码的话，我们会发现一个问题：程序崩溃了。 中间的混沌虽然在一开始，我们已经把 malloc 给 overload 掉了，但是我们实际的内存分配还是需要通过 dlsym 获取到 glibc 里真正的 malloc 等内存操作函数指针。 而真正的 malloc(aka tmalloc, true-malloc)，和我们自定义的 malloc(aka cmalloc, customized-malloc) 中间，有一段还没 dlsym 的真空期。 LD_PRELOAD 重载 malloc。 malloc 真空期。 &lt;– we are here dlsym 真正的 malloc。dlsym 内的 malloc 当前是 cmalloc！ 将 tmalloc 放进 cmalloc 中。 问题就出在 dlsym 和 printf 等函数，内部也是包含了 malloc 的，也就是说掉进了先有蛋还是现有鸡的陷阱里。在 dlsym、printf、fprintf 等函数内调用到的 malloc 是 cmalloc，而 cmalloc 里又包含了 tmalloc 的调用。在这个真空期里，我们无法获取到 tmalloc 的指针，进而导致了程序的崩溃。 问题已经抛出来了，那么我们有解决办法吗？当然是有解决办法的：用 stack 代替 heap。 众所周知，虽然对内存区分了 stack、heap 等等，但是其实都是同一块内存条上的东西在那边写写画画，区别只是 stack 的容量远小于 heap。那么，tmalloc 拿到的 heap 区内存指针其实也可以用 stack 区的内存指针来代替。这就是我们如何填补上这个无法获取到 heap 区内存指针的真空区的办法：使用一个 stack 上的假 malloc(aka smalloc, stack-malloc)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define ALIGN(x) ((x + (sizeof(size_t) - 1)) &amp; ~(sizeof(size_t) - 1))#define MY_HEAP_SIZE (2 * 1024 * 1024)char my_heap[MY_HEAP_SIZE];bool inner_call = true; // 混沌期标识void* smalloc(size_t size) &#123; size_t alloc_size = ALIGN(size) + sizeof(size_t); if (MY_HEAP_SIZE - my_heap_pos &gt;= alloc_size) &#123; char* p = my_heap + my_heap_pos; *(size_t*)p = size; p += sizeof(size_t); my_heap_pos += alloc_size; return p; &#125; return NULL;&#125;void __attribute__((constructor)) init() &#123; if (inited) &#123; return; &#125; void* (*tmp_malloc)(size_t size); // 混沌期开始 inner_call = true; *(void**)(&amp;tmp_malloc) = dlsym(RTLD_NEXT, &quot;malloc&quot;); if (!tmp_malloc) &#123; frintf(stderr, &quot;load function fail %s\\n&quot;, dlerror()); exit(-1); &#125; tmalloc = tmp_malloc; // 混沌期结束 inner_call = false; inited = true;&#125;extern &quot;C&quot; void* malloc(size_t size) &#123; // init, etc if (inner_call) &#123; // memory space for dlsym, printf etc return smalloc(size); &#125; // 下面的调用需要是栈区 smalloc，否则会递归 cmalloc inner_call = true; // do customized things // ... // 混沌结束 inner_call = false; return (p + 1);&#125; 多线程经过上面一通操作以后，我们已经把 malloc hook 进了程序里，并且可以愉快的跑起来。 12export LD_PRELOAD=./libmck.sols 但是现在的服务端进程，是不可能只有单线程的。当多线程被引入，很快我们就发现程序还是会崩溃，stack overflow。问题出在 inner_call 是个全局变量，不是每个线程独占的，所以可能某个线程 inner_call 结束了，但是别的线程还在继续，就导致了递归的 cmalloc 情况出现。 既然是每个线程需要有自己独立的状态，自然就想到了 __thread 这个修饰符。其修饰的变量在每个线程都有自己独立的一份空间，不会有互相冲突的情况。 1__thread bool inner_call = true; 内存占用排序解决掉各种各样的问题之后，终于到了最后一步：统计内存使用情况。对于这个部分的实现倒不用很详细的讲，各花入各眼，想怎么实现就怎么实现了。在作为样例的 project 里，是维护了一个最大堆，把所有的内存占用依据大小给存进来。 backtrace 之殇对于调用栈的记录，目前使用的是简单粗暴的 backtrace，也就是每次 malloc/free 都会调用一次 backtrace。明眼人一看就出来了：这不是 cpu 会飙的飞起吗？ 是的，使用这个方法会极大影响到程序性能。 所以考虑其他办法则成为了这个工具的下一个问题。 原子操作待续。","categories":[],"tags":[],"keywords":[]},{"title":"性能优化那些事","slug":"performance_optimization","date":"2021-01-04T15:07:26.000Z","updated":"2021-10-28T08:03:23.553Z","comments":true,"path":"2021/performance_optimization/","link":"","permalink":"https://zengzengyu.com/2021/performance_optimization/","excerpt":"","text":"C++ 程序员，比起其他的程序员，可能骨子里更喜欢“性能”这个词。毕竟 C++ 难写又难编，包管理一塌糊涂。部署更是离谱，还要看 glibc 的版本（Java: 你在说啥）。所以“性能”二字便成为了一个类似遮羞布的存在了，哈哈。 lock free 被作为一种性能优化技术提出，主要是因为 mutex lock/unlock 时，会有 sys call，导致软中断。频繁的软中断，这几个保存 lwp context 压栈出栈的操作，并频繁让出、占用 cpu 的行为很容易就成了性能瓶颈。 一般情况下，优化程序的性能不外乎三点：CPU、内存、IO。 CPUCPU 可以用 perf 来看热点函数，哪些函数执行的次数最多、占用最多 CPU 时间片。火焰图依赖于推栈和符号表，对于整个进程，使用 perf 进行 profile 意义不大，因为多线程程序很容易有大量的时间片在 cond_wait(futex) 里。基于 linux lwp 的概念，可以深入到某几个业务线程里进行 profile。但是这只能提供一个大体的方向而已，因为函数名一般都会掉到 C++ 的标准库或者 kernel 的函数里，最后你还是得一行行代码去抠。顶多知道哪个函数被调用最多，是不是写了个什么很挫的循环在里面。 123456# active recperf record -g -p xxx,xxx sleep 600# offcpuperf probe -a futexperf probe -x /lib64/libc.so.6 malloc 平时常用的 perf 指令如上，一般是在 profile 了指定线程后，发现很多 malloc/futex 等等的调用，则可以继续使用 perf probe 插桩。通过指定桩的调用栈打点来确认这些桩点都是如何进来的，提供进一步优化的依据。 对于我这几年的经验，一般不需要做什么把 string 的 key hash 成 int 以提高后续比较性能的事情。最多的还是数据结构选取的不合理，比如将所有的任务储存在一个 list 里，然后每次都去遍历那个 std::list&lt;Task&gt; 来找到需要停止的任务。一个 std::map&lt;TaskID, Task&gt; 就直接让性能提升了二十倍。 当然，能避免频繁的 sys call 最好还是避免掉，举个例子。 记录耗时惹出的事比如：gettimeofday()，这个调用好像很多人没想到是一个 sys call。在一些性能敏感的场景里，例如对一张图片提取特征的耗时，会在多处打桩，以避免出现返回慢等问题时像无头苍蝇一样乱找。对于 c++，std::chrono 或者 gettimeofday 其实差异不大，都是一个 sys call，获取系统时间。 但是在高并发场景下，每秒几千几万张的图片送进来，打桩时频繁获取时间则成了一个很重的负担。这也是知道了结论以后的倒推，通过 perf 只能看到是在频繁获取时间，日志、打桩、染色 id 等场景都会涉及到时间的获取。只有在打桩的时候，才会持续的去获取时间戳，记录耗时。 既然知道是频繁的获取时间导致的性能问题，那么我们就把获取时间戳的这个行为从 sys call 降级为一个用户态的事情：单独起一个线程，通过 usleep 来获取精确到毫秒的时间戳。atomic + volatile，这两板斧下去，就把打桩的 sys call 成功降级为了一个 atoimc get。更进一步，其实这个时间戳只有一个 setter，多个 reader，只要更新频率够得上需要的精度，没有必要再包上一层 atomic。既然封装出了一个用户态时间获取，其他获取时间的场景也都可复用这个线程的数据。 当然，这个实现也有一个很明显的问题：太占 CPU 了。在 HPC 里，一个机器 64 或者 86 个核，这种单开一个线程没什么影响，但是要是移动端呢？ 内存现在的机器内存一般不会成为瓶颈。对于 C++，内存可优化的点一个是避免传参数时的隐式复制，一个就是避免过多的 cache miss。 隐式复制没什么好说的，传参数的时候多用引用和指针吧。最好少用指针，因为你可能会忘了写判空，不知道什么时候就跑飞了。 更严重的是，经常有人上层做一个 vector 或者 shared_ptr，避免内存泄漏。但是下层接数据的函数参数又给写成了指针。那么传的时候，要么 vector.data()，要么 shared_ptr.get()。最后，一层层传下去的这个指针，指向的类早就析构掉了，而某个异步的回调还在用。这个指针指向的堆内存，可能还不会马上被其他 malloc 用掉，在一小段时间内是合法的，跑了一会儿后才飞掉。碰上这种垃圾代码导致的问题，自求多福吧。 cache miss其实这个东西归纳在 IO 里比较好。一般性能优化也不会抠到这里来。但还是说一说吧，这个东西 IO当涉及到 IO，很多东西就显得无趣起来了。一样，举个例子吧。 NON_BLOCKING一开始，之前的老哥用现成的 libuv 来实现一个 http server，做一个特征提取服务。会有很多的 client 向 server 发起链接，发送一张图片后，server 对图片提取特征再返回给 client。起了若干个 worker 线程，经典的 one thread per connection，从 server socket 里捞链接出来读图片、提取特征、再返回。 但是性能很差。 因为 GPU 提取图片特征的时候是做了一个 batch，送入一张图片不会马上提取，而是使用 (五十张 || 等待满 15ms) 这个条件来进行特征提取。在这个业务场景下，显然不可能根据 GPU batch 的图片张数来增加 worker 线程。而每个 thread 都来取个五十张呢？也不对，因为你无法感知到 pending 的 client socket 有多少，肯定会出现 worker thread 负载不均的情况。 这时候，就需要一个 scheduler 的出现了。不是 worker thread 自己去 pending socket 里捞，而是通过 scheduler 定期获取 pending socket，然后 round-robin 往里塞。把 server socket 变成 NON_BLOCKING，scheduler 从里面捞到 EAGAIN 为止，然后再塞到 worker 里。 哈哈，这不就是 reactor 模型吗。 当然，里面还涉及到很多细节。比如：scheduler 要一次全捞完吗？不全捞的话，一次捞多少呢？碰上 ddos 怎么办？由于内存到 GPU 走的 PCIE，worker 向 GPU 送图时需不需要也做一个 batch？ 通用的高性能代码性能优化这种事，其实是高度定制化的。特别是抠到最后，还会有内嵌汇编、magic number 等等奇技淫巧，就是为了快上那么 1ms。 不可能有一个人写出了性能特别高，代码又十分通用、简介的模块。里面肯定塞满了各种特例、对平台判断的 if else，等等。","categories":[],"tags":[],"keywords":[]},{"title":"分布式的一致性","slug":"dist_consis","date":"2020-12-15T08:36:09.000Z","updated":"2021-10-28T08:03:23.553Z","comments":true,"path":"2020/dist_consis/","link":"","permalink":"https://zengzengyu.com/2020/dist_consis/","excerpt":"","text":"paxosraft生产环境","categories":[],"tags":[],"keywords":[]},{"title":"C++ POD 内存操作","slug":"cpp_memop","date":"2020-02-24T14:18:35.000Z","updated":"2021-10-28T08:03:23.552Z","comments":true,"path":"2020/cpp_memop/","link":"","permalink":"https://zengzengyu.com/2020/cpp_memop/","excerpt":"","text":"C++ 在涉及到网络编程情况下，一般操作是在一个 header 里带上 attachment 的长度，再分配一个对应长度的 buffer 接收 attachment。但是一些情况下，无法预先分配一个恰到好处的 buffer 来接收数据，比如使用 curl 时。所以需要对不同的 buffer 操作方式进行比较，从而得出最佳操作的方式。 以下 benchmark 是对一个 2mb 的内存块操作。 12345678910111213硬件概览： 型号名称： MacBook Pro 型号标识符： MacBookPro15,4 处理器名称： 四核Intel Core i5 处理器速度： 1.4 GHz 处理器数目： 1 核总数： 4 L2缓存（每个核）： 256 KB L3缓存： 6 MB 超线程技术： 已启用 内存： 8 GB 系统固件版本： 1554.80.3.0.0 (iBridge: 18.16.14347.0.0,0) 激活锁状态： 已启用 memset vs std::fillmemset 是 asm 内嵌的操作，而 std::fill 是一个模版壳子的 for 循环，所以性能差距会很大。但我没想到会这么大。 memset std::fill 1000 次 341ms 17323ms memcpy vs std::copystd::copy 的内部实现其实就是 memcpy/memmove, 所以性能差距不会很大，甚至 std::copy 会表现比 memcpy 更好。 memcpy std::copy 100000 次 1184ms 1175ms 实际操作 vector reserve copy reserve 一个 2mb 的 vector 作为 buffer copy 2mb 的内存块到 vector 内 析构 vector resize copy resize 一个 2mb 的 vector 作为 buffer copy 2mb 的内存块到 vector 内 析构 内存块 malloc 一个 2mb 的 char* 作为 buffer copy 2mb 的内存块到 char* 内 free vector insert reserve 一个 2mb 的 vector 作为 buffer insert 2mb 的内存块到 vector 内 析构 vector reserve copy vector resize copy 内存块 vector insert 100次 337ms 21972ms 400ms 10594ms 使用 vector 的 resize、copy 来向后 append 数据。这种办法是效率最低，但是也是（内存管理）最安全的方法。由 vector 来管理分配的堆空间。影响主要是 resize 会调用 std::fill，导致性能极差。 使用 vector 的 insert 来补充进入的数据。这种办法看似比 resize 效率高，但是涉及到 capacity 不足导致 vector 重新分配堆空间、拷贝原先数据的情况。可以使用 reserve 一个较大空间来避免这种情况，但是还是无法完全避免。insert 也类似于 fill，是一个循环。 使用 char* malloc 内存数据。这种办法是理论上最快的办法，可以使用 unique_ptr 来避免内存泄漏。虽然过程中会有重复的 malloc、memcpy，但是 memcpy 是 asm 操作，比套一层模板外壳的 for 循环性能高上许多。malloc 也可参考 vector 的实现，每次重新 malloc 都是 2*capability。 使用 char* realloc 内存数据。这个办法是 curl 官方网站提供的。但是一般情况下 realloc 是不安全的，因为realloc 后的指针可能指向一个新的堆。 旧的内存区无法清空，可能会有敏感数据。 会有人写的比较挫，类似 p = realloc(p, new_size);。如果分配失败会导致 p 直接丢失。 其实 realloc 就是做了上面 malloc、memcpy 的事情，但是丢失了一定的自由度。当然，curl 官方这么写，是安全的。但是一般情况下，realloc 应该作为最后的一个选项出现。","categories":[],"tags":[],"keywords":[]},{"title":"lock free - 自顶向下","slug":"lock_free_topdown","date":"2020-02-05T08:08:01.000Z","updated":"2021-10-28T08:03:23.553Z","comments":true,"path":"2020/lock_free_topdown/","link":"","permalink":"https://zengzengyu.com/2020/lock_free_topdown/","excerpt":"","text":"lock free 作为性能控们眼中的弄潮儿技术，自然是有着让人难以抗拒的性能魅力。 但是在讨论 lock free 之前，我们先来大概看看 lock 吧。毕竟没有对比，就没有对性能的概念。 spin lockspin lock 会在一个死循环内反复尝试，直到拿到锁为止。优点：如果获取不到锁，也不会陷入内核态。不会响应中断。缺点：CPU 占用极高。这种锁一般用在 log 模块内，向 log buffer 写时使用 spin lock。 semaphore信号量的实现可以认为是一种带了引用计数的锁，内部应用了 spin lock 来保护引用计数。 mutex lock最常见的锁，也是最应该被用到的锁。可以看作是引用计数为 1 的 semaphore。如果获取不到锁，会触发软中断，陷入内核态，让出 CPU，让内核来调度下一个时间片。使用这种锁最坏情况是某个线程死锁，是一种万金油锁，大部分场景用它都不能说是错的。 recursive lockmutex lock 的可重入版本。如果同一个线程对同一个 mutex 反复加锁，不会导致死锁。在解锁时也需要和加锁次数配对的解锁次数。这种锁在应用上一般是写的很挫的东西，实在用 mutex 改不动了才会加一个 recursive。 rwlock读写锁，实现为加了 read count 和 write count。可以把 read lock 当成多线程方面的 recursive lock，write lock 方面的 mutex lock。一般来说适用于配置方面的保护。 性能比较12345678910111213硬件概览： 型号名称： MacBook Pro 型号标识符： MacBookPro15,4 处理器名称： 四核Intel Core i5 处理器速度： 1.4 GHz 处理器数目： 1 核总数： 4 L2缓存（每个核）： 256 KB L3缓存： 6 MB 超线程技术： 已启用 内存： 8 GB 系统固件版本： 1554.80.3.0.0 (iBridge: 18.16.14347.0.0,0) 激活锁状态： 已启用 使用以上介绍的几种锁，开启 4 个线程，对同一个 stack 进行 push、pop 操作，获取其吞吐量。 1 push, 3 pop在使用 rwlock 时，对这种场景的性能测试没有什么意义。 atomicmemory barrierCAS","categories":[],"tags":[],"keywords":[]},{"title":"内存越界怎么办","slug":"dig_segfault","date":"2019-03-17T15:36:39.000Z","updated":"2021-10-28T08:03:23.553Z","comments":true,"path":"2019/dig_segfault/","link":"","permalink":"https://zengzengyu.com/2019/dig_segfault/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"让服务器记住你","slug":"让服务器记住你","date":"2017-08-07T07:24:00.000Z","updated":"2021-10-28T08:03:23.553Z","comments":true,"path":"2017/让服务器记住你/","link":"","permalink":"https://zengzengyu.com/2017/%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%B0%E4%BD%8F%E4%BD%A0/","excerpt":"","text":"123456789101112131415161718192021222324252627# generate pub and priv keys, leave the passphrase empty# (simply press ENTER when asked for it)ssh-keygen #copy the pub key to the remote computer#(change port number if different from the usual 22)#change &quot;user&quot; to your user name#change &quot;host&quot; to your domain namescp -P 22 ~&#x2F;.ssh&#x2F;id_rsa.pub user@host:~&#x2F; #log on to the remote computerssh -p 22 user@host #create the .ssh directory in the root login directory, if it doesn&#39;t already existmkdir .ssh #append key to filecat id_rsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys #delete the public key file, no longer neededrm -f id_rsa.pub #log off the remote serverexit #logon to the remote server, without password promptssh -2 -p 22 user@host","categories":[],"tags":[],"keywords":[]},{"title":"基于百度地图 API 编写的出行助手 APP","slug":"基于百度地图-API-编写的出行助手-APP","date":"2017-02-09T14:11:40.000Z","updated":"2021-10-28T08:03:23.553Z","comments":true,"path":"2017/基于百度地图-API-编写的出行助手-APP/","link":"","permalink":"https://zengzengyu.com/2017/%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE-API-%E7%BC%96%E5%86%99%E7%9A%84%E5%87%BA%E8%A1%8C%E5%8A%A9%E6%89%8B-APP/","excerpt":"前几天接了个同济那边实验室的私活，写 Android APP 挣外快。这次的 APP 开发也让我接触到了很多以前没接触过的领域，感觉收益颇丰，特别是对方评价我的代码‘很专业’的时候，心里美滋滋，嘿嘿。","text":"前几天接了个同济那边实验室的私活，写 Android APP 挣外快。这次的 APP 开发也让我接触到了很多以前没接触过的领域，感觉收益颇丰，特别是对方评价我的代码‘很专业’的时候，心里美滋滋，嘿嘿。 导航百度地图的 API 提供了两个点之间的[骑行，步行，驾车，公共交通]路线规划，所需要做的就是获取起点和终点的经纬度(latitude，longitude)并调用对应的接口函数，会返回结构化的路线规划。之后再将路线绘制在地图上即可。实时的语音播报导航只支持驾车，所以只能退而求其次，进行不断地定位，并测试与关键点之间的距离来进行提示。当然，也就无法做到那种‘前方路口左转’这种细致的导航了。 搜索地点因为我们在实际使用中，不可能通过输入起终点的经纬度来进行路径搜索，所以我们需要将使用者输入的文字地点转化为对应的经纬度才能发起对路径的搜索。而百度地图的 map(文字，经纬度) 显然只能对应准确的文字地点，所以我们需要调用他的文字模糊搜索，首先将使用者‘不是很精确’的文字描述转化为‘精确的’文字描述，再转化为经纬度。第一步的转化通过直接进行搜索，然后填充 AutocompleteTextView 来建议使用者进行点选。 热点提示‘出行助手’所提供的功能之一就是显示附近的[自行车，汽车]租赁点，并引导使用者前往租赁点。这里所做的就是拉取交通工具提供商的各个租赁点所在经纬度，并在地图上进行标注。为了便于使用者查询租赁点剩余的车辆数，我还往里添加了‘点击获取租赁点详情’的功能，就是文字颜色不好选择，这个后期就交给他们的美工慢慢调整吧。 支付既然成为了寻找租赁点的入口，自然要接入租赁支付的功能，这里可以直接调用支付宝的接口，我比较懒，就直接调用了类似于‘支付宝扫码支付’的页面，让使用者直接跳转到支付宝APP进行支付。","categories":[{"name":"Android","slug":"Android","permalink":"https://zengzengyu.com/categories/Android/"}],"tags":[{"name":"地图","slug":"地图","permalink":"https://zengzengyu.com/tags/%E5%9C%B0%E5%9B%BE/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://zengzengyu.com/categories/Android/"}]},{"title":"LeetCode 解题报告: 174. Dungeon Game","slug":"LeetCode-解题报告-174-Dungeon-Game","date":"2016-09-30T09:35:03.000Z","updated":"2021-10-28T08:03:23.552Z","comments":true,"path":"2016/LeetCode-解题报告-174-Dungeon-Game/","link":"","permalink":"https://zengzengyu.com/2016/LeetCode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A-174-Dungeon-Game/","excerpt":"174. Dungeon Game The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. -2 (K) -3 3-5 -10 110 30 -5 (P) Notes: The knight’s health has no upper bound.Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.","text":"174. Dungeon Game The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. -2 (K) -3 3-5 -10 110 30 -5 (P) Notes: The knight’s health has no upper bound.Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. 这道题其实也是类似于动态规划, 弄个对应于迷宫的 minHealth 数组就行了, 迷宫的每一格对应于 minHealth 数组的每个下标位置. 首先把 minHealth 初始化为与所给迷宫数组相对应 size 的数组, 其中每一个元素初始值赋为 1. 然后从 Princess 所在的地方开始遍历, 若 Princess 所在的 dungeon[i][j] 值小于零, 则需要 minHeal[i][j] -= dungeon[i][j], 不然 knight 就死了嘛. 因为 knight 只能 down or right, 所以首先遍历最下边的一行和最右边的的一列. 最优化选择根据当前 dungeon[i][j] 的值进行判断. minVal 为可选的下个路径点之间得出的最小值. dungeon[i][j] &gt; 0 这里是加血, 所以只需要判断能不能加到下个地方所需要的最小 health, 若不能则需要修改 minHeal[i][j] = minVal - dungeon[i][j]. 判断条件为 minVal &gt; dungeon[i][j]. dungeon[i][j] == 0 这里基本可以忽略, 其实就是一个过渡格子, minHeal[i][j] = minVal. dungeon[i][j] &lt; 0 这里会扣血, 所以就直接往上加了, minHeal[i][j] = minVal - dungeon[i][j]. 到这里其实就差不多了, 剩下的都是一些小细节, 上代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;public: int min(int a, int b)&#123; return a&lt;b?a:b; &#125; int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; vector&lt;vector&lt;int&gt;&gt; minHeal; int m = dungeon.size(); int n = dungeon[0].size(); for(int i = 0; i &lt; m; i++)&#123; vector&lt;int&gt; temp; for(int j = 0; j &lt; n; j++)&#123; temp.push_back(1); &#125; minHeal.push_back(temp); &#125; if(dungeon[m - 1][n - 1] &lt; 0)&#123; minHeal[m - 1][n - 1] -= dungeon[m - 1][n - 1]; &#125; //buttom row for(int j = n - 2; j &gt; -1; j--)&#123; if(dungeon[m - 1][j] &gt; 0)&#123; if(minHeal[m - 1][j + 1] &gt; dungeon[m - 1][j])&#123; minHeal[m - 1][j] = minHeal[m - 1][j + 1] - dungeon[m - 1][j]; &#125; &#125; else if(dungeon[m - 1][j] == 0)&#123; minHeal[m - 1][j] = minHeal[m - 1][j + 1]; &#125; else&#123; minHeal[m - 1][j] = minHeal[m - 1][j + 1] - dungeon[m - 1][j]; &#125; &#125; //rightest row for(int i = m - 2; i &gt; -1; i--)&#123; if(dungeon[i][n - 1] &gt; 0)&#123; if(minHeal[i + 1][n - 1] &gt; dungeon[i][n - 1])&#123; minHeal[i][n - 1] = minHeal[i + 1][n - 1] - dungeon[i][n - 1]; &#125; &#125; else if(dungeon[i][n - 1] == 0)&#123; minHeal[i][n - 1] = minHeal[i + 1][n - 1]; &#125; else&#123; minHeal[i][n - 1] = minHeal[i + 1][n - 1] - dungeon[i][n - 1]; &#125; &#125; //inside the mat, except buttom line and rightest line for(int i = m - 2; i &gt; -1; i--)&#123; for(int j = n - 2; j &gt; -1; j--)&#123; int minVal = min(minHeal[i + 1][j], minHeal[i][j + 1]); if(dungeon[i][j] &gt; 0)&#123; if(minVal &gt; dungeon[i][j])&#123; minHeal[i][j] = minVal - dungeon[i][j]; &#125; &#125; else if(dungeon[i][j] == 0)&#123; minHeal[i][j] = min(minHeal[i + 1][j], minHeal[i][j + 1]); &#125; else&#123; minHeal[i][j] = minVal - dungeon[i][j]; &#125; &#125; &#125; return minHeal[0][0]; &#125;&#125;;","categories":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://zengzengyu.com/tags/LeetCode/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}]},{"title":"LeetCode 解题报告: 62. Unique Paths","slug":"LeetCode-解题报告-62-Unique-Paths","date":"2016-09-30T01:09:59.000Z","updated":"2021-10-28T08:03:23.552Z","comments":true,"path":"2016/LeetCode-解题报告-62-Unique-Paths/","link":"","permalink":"https://zengzengyu.com/2016/LeetCode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A-62-Unique-Paths/","excerpt":"62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Note: m and n will be at most 100.","text":"62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Note: m and n will be at most 100. 这道题挺简单的, 因为机器人被限定只能向左或向右移动, 并且 m 和 n 的最大值也被限定了, 所以可以直接用动态规划来做. 建立数组 mat 来记录每个点到终点的 ‘unique path’ 数. 比如 Oj 里给的范例是 3 * 7, 那么第 7 列所有的格子因为只能向下移动, 显然 ‘unique path’ = 1. 同理, 第三行所有格子也只能向右移动, ‘unique path’ = 1. 而其他的格子有两种选择, 要么向右要么向下, 即将右边格子和下边格子的 ‘unique path’ 加起来就行了. 1234567891011121314151617class Solution &#123;public: int uniquePaths(int m, int n) &#123; int mat[100][100]; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; mat[i][j] = 1; &#125; &#125; for(int i = m - 2; i &gt; -1; i--)&#123; for(int j = n - 2; j &gt; -1; j--)&#123; mat[i][j] = mat[i+1][j] + mat[i][j+1]; &#125; &#125; return mat[0][0]; &#125;&#125;;","categories":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://zengzengyu.com/tags/LeetCode/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}]},{"title":"LeetCode 解题报告: 23. Merge k Sorted Lists","slug":"LeetCode-解题报告-23-Merge-k-Sorted-Lists","date":"2016-09-29T13:18:21.000Z","updated":"2021-10-28T08:03:23.552Z","comments":true,"path":"2016/LeetCode-解题报告-23-Merge-k-Sorted-Lists/","link":"","permalink":"https://zengzengyu.com/2016/LeetCode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A-23-Merge-k-Sorted-Lists/","excerpt":"Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.","text":"Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 这道题很容易超时. 我对本题的第一反应: 不就是 Merge Sort 的实现吗… 但是这个数据结构是链表数组, 也就是说, 如果不把已经排序过的空链表 erase 掉, 会出错, 而每次 erase 操作的时间复杂度是 O(n), 每次 merge 因为是从 lists 里找最小值, 时间复杂度也是 O(n), 即总的时间复杂度为 O(n²). 超时. 另一个思路是, 首先对 lists 根据头结点的 val 进行逆序排序, 时间复杂度为 O(n * lgn). 之后直接取 lists[lists.size() - 1] 的头结点插入链表, 若取过之后为空则直接 lists.pop_back(), 时间复杂度为 O(1), 若取过之后不为空, 则重新调用排序算法对 lists 进行逆序排序. 最坏情况下的时间复杂度为 O(n² * k * lgn), k 为链表平均长度, 理想情况下时间复杂度为 O(n * lgn), 即每个链表只有一个结点. 所以该算法虽然在 LeetCode 被 ac 了, 但是在最坏情况下也会超时. 还有一个思路是建小顶堆, 然后每次取堆顶, 再移动被取的链表指针, 重新建堆. 此时的时间复杂度最坏情况其实也是 O(n² * k * lgn). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: static bool compare(ListNode* a, ListNode* b)&#123; return a-&gt;val &gt; b-&gt;val; &#125; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode *res, *resHead; resHead = res = NULL; for(int i = 0; i &lt; lists.size(); i++)&#123; if(lists[i]==NULL)&#123; vector&lt;ListNode*&gt;::iterator it = lists.begin(); lists.erase(it + i); i = -1; &#125; &#125; if(0 == lists.size())&#123; return resHead; &#125; sort(lists.begin(), lists.end(), compare); resHead = res = new ListNode(lists[lists.size() - 1]-&gt;val); lists[lists.size() - 1] = lists[lists.size() - 1]-&gt;next; if(lists[lists.size() - 1] == NULL)&#123; lists.pop_back(); &#125; else&#123; sort(lists.begin(), lists.end(), compare); &#125; while(true)&#123; if(0 == lists.size())&#123; break; &#125; if(lists[lists.size() - 1] != NULL)&#123; ListNode *temp = new ListNode(lists[lists.size() - 1]-&gt;val); res-&gt;next = temp; res = res-&gt;next; lists[lists.size() - 1] = lists[lists.size() - 1]-&gt;next; &#125; if(lists[lists.size() - 1] == NULL)&#123; lists.pop_back(); &#125; else&#123; sort(lists.begin(), lists.end(), compare); &#125; &#125; return resHead; &#125;&#125;;","categories":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://zengzengyu.com/tags/LeetCode/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}]},{"title":"LeetCode 解题报告: 57. Insert Interval","slug":"LeetCode-解题报告-57-Insert-Interval","date":"2016-09-29T12:08:58.000Z","updated":"2021-10-28T08:03:23.552Z","comments":true,"path":"2016/LeetCode-解题报告-57-Insert-Interval/","link":"","permalink":"https://zengzengyu.com/2016/LeetCode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A-57-Insert-Interval/","excerpt":"Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].","text":"Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 这题其实挺弱智的… 就是考虑各种 overlap 的情况, 然后直接 push_back 进结果即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: //has over lap //case 1: [intervals...&#123;newInterval...]...&#125; //case 2: &#123;newInterval...[intervals...]...&#125; //case 3: &#123;newInterval...[intervals...&#125;...] //case 4: [intervals...&#123;newInterval...&#125;...] vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; Interval merge; if(intervals.size() == 0)&#123; res.push_back(newInterval); &#125; for(int i=0; i&lt;intervals.size(); i++)&#123; //case 1: [intervals...&#123;newInterval...]...&#125; //case 2: &#123;newInterval...[intervals...]...&#125; //case 3: &#123;newInterval...[intervals...&#125;...] if(intervals[i].start &gt; newInterval.start &amp;&amp; intervals[i].end &gt;= newInterval.end &amp;&amp; intervals[i].start &lt;= newInterval.end || intervals[i].start &gt; newInterval.start &amp;&amp; intervals[i].end &lt; newInterval.end || intervals[i].start &lt;= newInterval.start &amp;&amp; intervals[i].end &gt;= newInterval.start &amp;&amp; intervals[i].end &lt; newInterval.end)&#123; if(intervals[i].start &lt;= newInterval.start &amp;&amp; intervals[i].end &gt;= newInterval.start &amp;&amp; intervals[i].end &lt; newInterval.end)&#123; merge.start = intervals[i].start; &#125; else if(i==0 || (intervals[i - 1].end &lt; newInterval.start &amp;&amp; intervals[i].start &gt; newInterval.start))&#123; merge.start = newInterval.start; &#125; if(intervals[i].start &gt; newInterval.start &amp;&amp; intervals[i].end &gt;= newInterval.end &amp;&amp; intervals[i].start &lt;= newInterval.end)&#123; merge.end = intervals[i].end; res.push_back(merge); &#125; else if(i==intervals.size() - 1 || (intervals[i + 1].start &gt; newInterval.end &amp;&amp; intervals[i].end &lt; newInterval.end))&#123; merge.end = newInterval.end; res.push_back(merge); &#125; &#125; //&#123;newInterval...&#125;[intervals...] else if(i == 0 &amp;&amp; intervals[i].start &gt; newInterval.end)&#123; res.push_back(newInterval); res.push_back(intervals[i]); &#125; //&#123;newInterval...&#125;[intervals...] else if(i == intervals.size() - 1 &amp;&amp; intervals[i].end &lt; newInterval.start)&#123; res.push_back(intervals[i]); res.push_back(newInterval); &#125; //[intervals...]&#123;newInterval...&#125;[intervals...] else if(intervals[i].start &gt; newInterval.end &amp;&amp; intervals[i - 1].end &lt; newInterval.start)&#123; res.push_back(newInterval); res.push_back(intervals[i]); &#125; //case 4: [intervals...&#123;newInterval...&#125;...] else&#123; res.push_back(intervals[i]); &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://zengzengyu.com/tags/LeetCode/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}]},{"title":"LeetCode 解题报告: 45. Jump Game II","slug":"LeetCode-解题报告-45-Jump-Game-II","date":"2016-09-29T11:03:36.000Z","updated":"2021-10-28T08:03:23.552Z","comments":true,"path":"2016/LeetCode-解题报告-45-Jump-Game-II/","link":"","permalink":"https://zengzengyu.com/2016/LeetCode-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A-45-Jump-Game-II/","excerpt":"Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. For example:Given array A = [2,3,1,1,4] The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.) Note:You can assume that you can always reach the last index.","text":"Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. For example:Given array A = [2,3,1,1,4] The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.) Note:You can assume that you can always reach the last index. 该题我本来想用类似于动态规划的方法来解, 即令创建一个 Count 数组来存储从数组开头移动到对应 index 的步数, 初始值赋为 INT_MAX, 从头开始遍历, 范围是 [index, index + array[index] &gt; array.size() ? index + array[index]:array.size()]. 时间复杂度最坏情况下为 O(n²), 自然超时了. 后来机智的我想到了, 既然 index 位的数字已经赋予之后位的数字步数了, 如果已经被赋值之后位的数字的最大步长仍然无法’接触’到未赋值的的位, 则必然比原来的步长小. 类似于 [index....[index2 ...]..] 这样的包含状态, 可以很明显地看出, 若对 index2 进行步数遍历, index2 范围内的步数必然大于 index 范围内的步数. 所以此时可以直接 break, 不用管 index2 范围内的了. 此时将 Count 数组初始值赋为 0, 若 Count[index + (index + array[index] &lt; array.size() ? array[index]:(array.size() - index - 1))] != 0, 则表明此时 index 被包含在了之前的已经遍历过了的范围内, 直接跳出循环, 进行下位的范围遍历. 此时的时间复杂度为 O(n). 以下为代码: 1234567891011121314151617181920class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; count; for(int i=0; i&lt;nums.size();i++)&#123; count.push_back(0); &#125; for(int i=0; i&lt;nums.size();i++)&#123; int bound = (nums[i] + i) &lt; nums.size() ? nums[i]:(nums.size() - i - 1); for(int j=bound; j &gt; 0; j--)&#123; if(count[j + i] != 0)&#123; break; &#125; count[j + i] = count[i] + 1; &#125; &#125; return count[nums.size() - 1]; &#125;&#125;; It’s easy, huh.","categories":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://zengzengyu.com/tags/LeetCode/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"https://zengzengyu.com/categories/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}]},{"title":"Android Imapge DPI","slug":"Android-Imapge-DPI","date":"2016-05-29T07:53:09.000Z","updated":"2021-10-28T08:03:23.552Z","comments":true,"path":"2016/Android-Imapge-DPI/","link":"","permalink":"https://zengzengyu.com/2016/Android-Imapge-DPI/","excerpt":"","text":"安卓 ImageView 的默认 DPI 问题因为最近在弄 Excited BBS，在设置开始画面的时候发现渲染的图像分辨率超过 OpenGl 的上限(2400*4800), 搜索一番之后发现是图片的默认 DPI 问题，在 1@drawable 里面，有 HDPI, XHDPI 等等子文件夹，里面就是不同的 DPI 设置，此时我们就把所需要的图片放在 1NODPI 里面，这样 ImageView 渲染的 DPI 就不会乱跑了。","categories":[],"tags":[{"name":"Android-Develop","slug":"Android-Develop","permalink":"https://zengzengyu.com/tags/Android-Develop/"},{"name":"Image","slug":"Image","permalink":"https://zengzengyu.com/tags/Image/"}],"keywords":[]}]}